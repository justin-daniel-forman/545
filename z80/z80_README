/******************************************************************************
 * Zilog Z80 Emulator                                                         *
 * Authors: Justin Forman and Suyash Bhatt (here and there)                   *
 * Date:    11/30/2016                                                        *
 * ***************************************************************************/

1) Overview:
  This project serves as a mostly-functional Zilog Z80 Microprocessor in
  observance of the original Z80 ISA. Some features of the original processor
  have been omitted and others are not completely verified. Those sections
  are documented in the TODO section, later in this guide. Additionally,
  the original ISA is observed, but the microarchitecture varies from the
  original design, and as such, any undocumented opcodes are unsupported,
  but may be added with minimal difficulty.

2) z80 File Overview:
  - z80_top.sv :
      This file contains the top level declaration of the processor.
  - z80_datapath.sv:
      This file contains the entire datapth of the processor.
  - z80_control_macro.sv:
      This file contains the control path of the processor with
      pre-compilation macros that need to be interpreted before you
      can have a working design. These macros are interpreted
      by the various perl scripts tied into the Makefile.
  - z80_control.sv:
      This file contains the post-compilation control path that
      is a working design since all of the macros have been
      removed. Do not edit this file directly, as it will
      be wiped out after every compile.
  - z80_defines.vh:
      This file contains the contstants that are used in the
      design.
  - z80_memory.sv:
      This file contains a "simulated" memory space for the processor
      to use in simulation. It is only tied together with the processor
      in the testbench files.
  - z80_ports.sv:
      This file contains a "simulated" i/o port space for the processor
      to use in simulation. It is only tied together with the processor
      in the testbench files.

3) Testbench File Overview:
  These files are contained in /z80/tb/
  - Makefile:
      This file allows you to compile and simulate the processor with the
      simulated memory and I/O. An overview of this file is contained
      in the USAGE section.
  - testbench.pl:
      This file is called by the Makefile to 1) Parse the assembly file
      located in /z80/tb/traces/, and load the binary into the simulated
      memory, 2) Potentially compare the output of the simulation to
      a known dump file, 3) Potentially repeat this process for every
      .asm file in the traces/ directory.
  - macros.pl:
      This file contains all of the complex Macros that we use in our
      verilog files. The file is pretty messy and hacked together,
      but it operates off a few simple regexes that are easy to
      copy/paste to make your own custom macros.
  - traces/assembler.pl:
      This file is a wrapper for sarcasm.pl, which is the open source
      z80 assembler that we are using to assemble our test programs.
      Credit to: Phillip Jacob Smith

4) Building your design:

  1. Navigate to z80/tb/ -- the Makefile for the z80 processor is located in this
     directory along with all of the necessary perl scripts to build the design.

  2. To compile your verilog (and macros), run the command: 'make top'. This
     command will first replaceall of the macros in z80_control_macros.sv and
     create a file called z80_control.sv. Then, the command will
     use vcs to compile all of the changes to z80_control.sv, z80_top.sv,
     z80_datapath.sv, and z80_defines.vh.

  3. To test your design, run one of the following 3 commands:
      - 'make debug-file [test-name minus extension]'
          This command will load the specified assembly file into memory
          and then execute it on the processor. It will print the
          state of the processor every clock cycle, and a final
          state.
      - 'make verify-file [test-name]'
          Same as above, but compares the final state to a known .dmp
          file to check for differences.
      - 'make verify-all'
          Same as above, but automatically runs for every .asm file in the
          traces directory.

5) Known Bugs and Missing Features:
  The design is functionally equivalent to the ISA manual from a functional
  standpoint, except for the following changes:

  1) Maskable Interrupt Acknowledge - In the original z80, the interrupt
      line is sampled in the last cycle of every instruction. In this
      processor, it was easier to sample the interrupt line in the
      first cycle of the next instruction. Because of this, we had
      the following problem: When an EI executes, interrupts
      cannot be acnknowledged until after the end of the atomic
      instruction. When sampling in the last cycle of EI, interrupts
      are still disabled, so you must execute the next instruction
      of the regular program. When we moved the check, you could
      take the interrupt instead of executing the next program
      instruction. This is problematic for the following two
      consecutive opcodes: EI, RET. Normally the RET would
      always execute when returning from an interrupt, but we were
      getting interrupted before returning from the interrupt handler.
      We fixed this by insterting a 1 instruction delay between EI and
      having interrupts be acknowledge to ensure that we are compatible
      with code that returns from interrupts this way.
  2) Bus Acknowledge and DMA interface not implemented - We didn't have
      time to implement this, and so you cannot request the bus from
      the processor. It would be pretty easy to implement this feature
      yourself if you so desired.
  3) HALT_L not implemented - We also didn't have time/ a need to do this.
  4) WAIT_L not implemented - Since we are clocking our memory much, much
      faster than our processor, we had no need to implement this WAIT_L
      signal, which essentially halts execution of the processor until the
      memory access returns. This could be a significant feature that is
      hard to implement in our microarchitecture.
  5) Unverified Instructions - The following instructions are either not
      implemented or are not fully vetted:
        RETN
        RETI
  6) Non-Maskable Interrupt Acknowledge - This code is started, but not finished.
      It would be easy to finish if desired.
  7) CALL and RET - call and return are both broken, but they are broken
      symmetrically such that the problem will only surface in a specific way.
      CALL stacks the PC that you are supposed to return to minus one. RET
      unstacks that PC, and then increments it. This breaks if you were to
      add your own return address to the stack, then return from it. In that
      case, you would return to that addres + 1, which is not desirable. This
      would be an easy fix.

6) MicroArchitecture Overview
  The original z80 had a pretty simple architecture. There were two internal
  busses: a 16-bit address bus and an 8-bit data bus. These busses connected
  several registers, the control logic, and a single 4-bit alu. Every cycle,
  the decoder in the control logic would assert some control points that would
  move some data from the registers through the ALU, and back to some other
  registers. During some cycles, you assert the values on the internal
  busses onto the external busses, which are used to interact with memory
  and I/O devices.

  All we knew from the ISA manual was how many clock cycles each
  opcode took to execute and approximately which "routines" it used to
  accomplish the intended behavior. "Routines" were things like Memory Reads,
  Operand Data Fetches, and Memory Writes. We didn't have access to clock
  cycle specific documentation, so we had to improvise.

  Our implementation operates in much the same way. Our approach is pretty
  much micro-code that is hardcoded into one giant control fsm. Each cycle
  we assert some control points that move data on the busses between
  registers. There is no pipelining, branch prediction, or anything that
  is otherwise fancy. In order to lessen our burden of writing microcode
  for every cycle of every insruction exactly the way it was laid out in
  the original processor, we made a few improvements that lessened the
  burden on the microcode.

  First, we upped the alu from 4 bits to 8 bits. This way we could perform
  all 8-bit arithmetic in a single cycle. And then we added a second 16-bit
  ALU for any address computations. This saved us the burden of making 16-bit
  additions compositions of 8-bit additions. This saved us a lot of time,
  but it also required us to implement more routing logic, which meant more
  control points, which meant more potential for errors.

  We also included a lot of point-to-point connections between the registers
  and the registers, the registers and the ALU, and the registers and some
  temporary registers. This allowed us to move multiple pieces of data
  simultaneously while we put values out on the busses. For example, this
  allowed us to perform computation at the same time as a memory read,
  when the address bus would otherwise be occupied. This optomization
  helped us meet a few corner cases in timing. In retrospect, the end design
  ended up being littered with ill-documented p2p connections like this,
  which could have been designed better at the beginning.

7) Control Path Overview:

  Decoder: The decoder is responsible for interpreting the current state
    of the processor and deciding the internal control points for moving
    data and beginning transactions. The pieces of the decoder are listed
    below.

  - State Declaration:
      This is the part of the decoder where we list all of the states in the enum.
      Use the macro: 'MACRO_DEFINE_STATES [state_name] [num_states]'
  - Next State Logic
      This part of the decoder tells us where to go based on the opcode fetched.
      We need to tell the FETCH cycles where to start our opcode and we need
      to sequentially define our states to step through each cycle.
      Use the macro 'MACRO_ENUM_STATES [state_name] [num_states]'
  - Output Logic
      This is the part of the decoder where we actually write the microcode
      based on how we want to manipulate the datapath. There are many macros
      for this part, which are documented in macros.pl.

  Bus FSMs: There are a series of FSMs that are kicked off by control signals
      asserted by the Decoder. These FSMs control the synchonization signals
      that our chip produces, such as MREQ_L and IORQ_L for any kind of
      external transaction, like a memory read, a memory write, an io read,
      an io write, or an interrupt acknowledge.


8) Data Path Overview:

  The datapath got a bit more convoluted than I had hoped during the course
  of this project. When I hit a corner case that I hadn't designed for,
  I didn't have time to remedy the situation as best as I would have like,
  so there are a few things in there that really shouldn't be. Nevertheless,
  here's a quick overview.

  The parts of the datapath are as follows:
    - Non-Regfile Registers
    - Register File
    - ALU
    - Other Registers

  Non-RegFile Registers:
    First off, the documented registers in the design are: A, F, B, C, D, E,
    H, L, IX, IY, SP, and PC. All of the single letter registers are 8-bits
    and the double letter registers are all 16-bits. However, registers
    B and C, D and E, and H and L are often grouped together to form 16-bit
    registers BC, DE, and HL. The 16-bit concatenations of these registers
    are used more often than their individual counterparts. On top of that,
    these 16-bit registers were updated sparingly when compared to A,
    the accumulator, and F, the flag register. Therefore, due to the size
    difference and frequency of use, it seemed natural to split up these
    two categories of registers. I placed all of the registers besides A and
    F inside of a "regfile" module that treated the rest of the registers
    as a bank of registers that could be addressed.

  Register-File:
    Since all of these other registers were pretty symmetric, I put them
    in a single module that was read and written symmetrically. The register
    file supports the following operations:
      1) 16-bit read: By driving both constituent 8-bit pieces of a 16-bit
          register you can output both on the out_double port. As a
          consequence, the 8-bit out_single port goes to high impedence,
          so you may not perform a 16-bit read simultaneously with an 8-bit
          read. This makes sense as the A register is often driven on
          the databus while the register file drives the addr bus, so there
          is no need for the register file to drive both busses at the same
          time.
      2) 8-bit read: However, if you only drive one of the constituent 8-bit
          registers, you can drive that onto the out_single port of the
          regfile.
      3) 16-bit write: Similar to before, if you assert the load signal
          for both constituent 8-bit registers of a 16-bit register,
          you can load in a value from the address bus into the 16-bit
          register. You can simultaneously perform a 16-bit write
          at the same time as an 8-bit read or a 16-bit read.
      4) 8-bit write: Also similar to before, we can load one of these
          registers by itself. We can do this in parallel with an 8-bit
          read or a 16-bit read.
      5) Context Swap: As per the ISA, some registers have a "naught"
          counterpart that is used for storing values instead of
          stacking them. This could be used for lightweight threading or
          maybe it is just an optimization to avoid stacking registers
          before function calls. Either way, you can perform this switch
          in a single cycle.
      6) Exchange: By asserting the swap input, you can swap the contents
          of any two 16-bit registers in a single cycle. This is used to
          solve some corner cases and is necessary for some of the EX
          instructions. This introduces a lot of point to point connections.


    The register file does not support the following behavior:
      1) You cannot perform an 8-bit and a 16-bit write at the same time.
      2) You cannot perform an 8-bit and a 16-bit read at the same time.

  ALU:
    There are 2 ALUs in the system. One is an 8-bit ALU and the other is
    16-bits. The ALU definition is parametrized, so the definition of
    each is actually the same. Each ALU takes two inputs and produces one
    output.

    The 8-bit ALU takes in the output of the Accumulator (A-register) and
    the muxed value of the data_bus with the TEMP register (more detail
    later). This allows us to perform any 8-bit arithmetic in a single
    cycle since the data-bus connects us to any other 8-bit register and
    the A-register is already hooked in. This point to point connection
    with the A-register is necessary otherwise both arguments would fight
    over the data-bus and a second cycle would be necessary to set up
    arguments.

    The 16-bit ALU takes in the output of the register file and the output
    of the TEMP register (more detail later). Similar to before, hooking
    the regfile to the ALU directly allows us to set up and perform any
    16-bit arithmetic in a single cycle.

    Really quickly, the TEMP register is used to hold data from the
    data bus that came in after a memory read that might be needed for
    some arithmetic. It is used to add to values in memory (8-bit mode),
    but more often it is used for address offset calculations from a
    constant value read from the opcode in memory (16-bit mode).

    The main problem with having 2-ALUs is that the ISA mandates a single
    set of flags that are used to determine processor state. As such, it
    is necessary to coalesce the flag output from each ALU together into
    a single F register. Therefore, each ALU takes in the current F state
    and the control path determines which ALU gets to write to the F reg
    in each clock cycle. This preserves the contract with the ISA to
    maintain a consistent state.

  Other Registers:
    As previously demonstrated by the TEMP register, there are some cases
    where we want to store some temporary values produced by the processor
    without having to stack them. As a result, the following registers
    were added to the processor:

    MDR1, MDR2: These are both 8-bit registers that sit on the data-bus
      and are used to load in values fetched from memory. There are 2 of
      them because 16-bit addresses are fetched from memory 8-bits at
      a time.

    MAR: This 16-bit register sits on the addr-bus and is used to store
      addresses that are composed in one of the ALUs. Often addresses,
      such as those created through offset calculations are to be discarded
      after the instruction terminates. We don't want to have to write that
      address back to the regfile in this case, so we can drop it in MAR
      after it is created in the ALU, then use MAR to drive the addr bus.

    TEMP: This register is differentiated from MDR1 and MDR2 because it
      has a point to point connection with both ALUs. This is necessary
      because it allows us to use the value in this register without
      using the data bus. This is necessary for some time-constrained
      instructions where we want to perform arithmetic on a previously
      fetched value at the same time as fetching a new value. This register
      isn't used much, but when it is, it is extremely helpful.

    STRH, STRL: These registers stand for Store High and Store Low. They
      create a 16-bit register that sits in the register file. This register
      exists for the same reasons as the above registers. When writing
      microcode for some instructions, it became apparent that having a temp
      register inside of the regfile could come in handy for PC calculations,
      among other things, so these registers were added to the design.

9) Bus Signal Overview:
  The output  bus signals are:
    -M1_L: Signifies that the processor is in opcode fetch mode, which
      usually signals the beginning of an instruction. I am not ultimately
      sure of the overall purpose of this signal in other systems, but
      it is essentially useless in our SMS project.
    - RFSH_L: In every op code fetch, the processor should refresh a DRAM
      value based on an auto-incrementing address register in the processor.
      Because a fetch occurs at the beginning of every instruction, the
      processor will loop through every DRAM address in a hopefully
      reasonable time, thereby allowing us to refresh every address without
      a dedicated memory controller. We don't do this in this design, so
      don't try to use this signal.
    - BUSACK_L: DMA synch signals that are not implemented in
      this design, so don't try to use these signals.
    - HALT_L: Signal that tells the outside world that the processor
      is in low-power mode. This is also not implemented.
    - RD_L: External read enable.
    - WR_L: External write enable.
    - IORQ_L: Signifies that the write enable and read enable are intended
      for an IO device.
    - MREQ_L: Signifies that the we and re are intended for memory.

  These signals are generated by set FSMs that are kicked off by the
    microcode in the decoder.

10) Acknowledgements:
  - Thanks to Charles MacDonald and smspower.org for providing reference
    material.
  - Thanks to Brandon Lucia for helpful advice.
  - Thanks to Suyash Bhatt for helping step in when we were up against
    some deadlines and for not committing too many bugs to this project.
